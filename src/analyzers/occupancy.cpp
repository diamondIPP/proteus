#include "occupancy.h"

#include <cassert>
#include <iostream>
#include <math.h>
#include <sstream>

#include <TDirectory.h>
#include <TH1D.h>
#include <TH2D.h>

#include "mechanics/device.h"
#include "processors/processors.h"
#include "storage/event.h"
#include "utils/root.h"

Analyzers::Occupancy::Hists::Hists(const Mechanics::Sensor& sensor,
                                   TDirectory* dir,
                                   const int occupancyBins)
{
  using namespace Utils;

  auto area = sensor.sensitiveAreaPixel();
  auto name = [&](const std::string& suffix) {
    return sensor.name() + '-' + suffix;
  };

  HistAxis axHitCol(area.interval(0), area.length(0), "Hit column");
  HistAxis axHitRow(area.interval(1), area.length(1), "Hit row");
  HistAxis axClusterCol(area.interval(0), area.length(0), "Cluster column");
  HistAxis axClusterRow(area.interval(1), area.length(1), "Cluster row");
  HistAxis axHitDist(0, 1, occupancyBins, "Hits / pixel / event");
  HistAxis axClusterDist(0, 1, occupancyBins, "Clusters / pixel / event");

  hitMap = makeH2(dir, name("HitMap"), axHitCol, axHitRow);
  hitOccupancyDist = makeH1(dir, name("HitOccupancyDist"), axHitDist);
  clusteredHitMap = makeH2(dir, name("ClusteredHitMap"), axHitCol, axHitRow);
  clusteredHitOccupancyDist =
      makeH1(dir, name("ClusteredHitOccupancyDist"), axHitDist);
  clusterMap = makeH2(dir, name("ClusterMap"), axClusterCol, axClusterRow);
  clusterOccupancyDist =
      makeH1(dir, name("ClusterOccupancyDist"), axClusterDist);
}

Analyzers::Occupancy::Occupancy(const Mechanics::Device* device,
                                TDirectory* dir,
                                const char* suffix)
    : SingleAnalyzer(device, dir, suffix, "Occupancy"), m_numEvents(0)
{
  assert(device && "Analyzer: can't initialize with null device");

  TDirectory* sub = Utils::makeDir(dir, "Occupancy");
  for (Index isensor = 0; isensor < device->numSensors(); isensor++) {
    m_hists.emplace_back(*device->getSensor(isensor), sub);
  }
}

TH2D* Analyzers::Occupancy::getHitOcc(Index isensor)
{
  validSensor(isensor);
  return m_hists.at(isensor).hitMap;
}

TH1D* Analyzers::Occupancy::getHitOccDist(Index isensor)
{
  if (!_postProcessed)
    throw std::runtime_error(
        "Occupancy: requested plot needs to be generated by post-processing");
  validSensor(isensor);
  return m_hists.at(isensor).hitOccupancyDist;
}

uint64_t Analyzers::Occupancy::getTotalHitOccupancy(Index isensor)
{
  return static_cast<uint64_t>(getHitOcc(isensor)->GetEntries());
}

void Analyzers::Occupancy::processEvent(const Storage::Event* event)
{
  assert(event && "Analyzer: can't process null events");

  // Throw an error for sensor / plane mismatch
  eventDeviceAgree(event);

  // Check if the event passes the cuts
  if (!checkCuts(event))
    return;

  m_numEvents += 1;

  // 0.- Loop in planes
  for (Index nplane = 0; nplane < event->numPlanes(); nplane++) {
    const Storage::Plane* plane = event->getPlane(nplane);
    Hists& hists = m_hists.at(nplane);

    // 1.- Loop in hits within plane and fill histos
    for (Index nhit = 0; nhit < plane->numHits(); nhit++) {
      const Storage::Hit* hit = plane->getHit(nhit);

      // Check if the hit passes the cuts
      if (!checkCuts(hit))
        continue;

      hists.hitMap->Fill(hit->posPixel().x(), hit->posPixel().y());
    }

    // 2.- Loop in clusters within plane and fill histos
    for (Index ncluster = 0; ncluster < plane->numClusters(); ncluster++) {
      const Storage::Cluster* cluster = plane->getCluster(ncluster);

      // Check if the cluster passes the cuts
      if (!checkCuts(cluster))
        continue;

      hists.clusterMap->Fill(cluster->posPixel().x(), cluster->posPixel().y());
      for (Index ihit = 0; ihit < cluster->numHits(); ++ihit) {
        const Storage::Hit* hit = cluster->getHit(ihit);
        hists.clusteredHitMap->Fill(hit->posPixel().x(), hit->posPixel().y());
      }
    }
  }
}

void Analyzers::Occupancy::postProcessing()
{
  auto fillOccupancyDist = [&](const TH2D* map, TH1D* dist) {
    // rescale occupancy histogram to available range
    dist->SetBins(dist->GetNbinsX(), 0, map->GetMaximum() / m_numEvents);
    dist->Reset();
    // fill occupancy
    for (int ix = 1; ix <= map->GetNbinsX(); ++ix) {
      for (int iy = 1; iy <= map->GetNbinsY(); ++iy) {
        auto count = map->GetBinContent(ix, iy);
        if (count != 0)
          dist->Fill(count / m_numEvents);
      }
    }
  };

  for (auto& hists : m_hists) {
    fillOccupancyDist(hists.hitMap, hists.hitOccupancyDist);
    fillOccupancyDist(hists.clusteredHitMap, hists.clusteredHitOccupancyDist);
    fillOccupancyDist(hists.clusterMap, hists.clusterOccupancyDist);
  }
}
