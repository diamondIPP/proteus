#include "occupancy.h"

#include <cassert>
#include <iostream>
#include <math.h>
#include <sstream>

#include <TDirectory.h>
#include <TH1D.h>
#include <TH2D.h>

#include "mechanics/device.h"
#include "processors/processors.h"
#include "storage/event.h"
#include "utils/root.h"

Analyzers::Occupancy::Hists::Hists(const Mechanics::Sensor& sensor,
                                   TDirectory* dir,
                                   const int binsPerClusterPixel,
                                   const int binsOccupancy)
{
  using namespace Utils;

  auto area = sensor.sensitiveAreaPixel();
  auto name = [&](const std::string& suffix) {
    return sensor.name() + '-' + suffix;
  };

  HistAxis axCol(area.axes[0], area.axes[0].length(), "Hit column");
  HistAxis axRow(area.axes[1], area.axes[1].length(), "Hit row");
  HistAxis axClusterCol(area.axes[0],
                        binsPerClusterPixel * area.axes[0].length(),
                        "Cluster column position");
  HistAxis axClusterRow(area.axes[1],
                        binsPerClusterPixel * area.axes[1].length(),
                        "Cluster row position");
  HistAxis axPix(0, 1, binsOccupancy, "Pixel hits / event");

  hits = makeH2(dir, name("HitMap"), axCol, axRow);
  clusteredHits = makeH2(dir, name("ClusteredHitMap"), axCol, axRow);
  clusters = makeH2(dir, name("ClusterMap"), axClusterCol, axClusterRow);
  pixelOccupancy = makeH1(dir, name("PixelOccupancy"), axPix);
}

Analyzers::Occupancy::Occupancy(const Mechanics::Device* device,
                                TDirectory* dir,
                                const char* suffix)
    : SingleAnalyzer(device, dir, suffix, "Occupancy"), m_numEvents(0)
{
  assert(device && "Analyzer: can't initialize with null device");

  TDirectory* sub = Utils::makeDir(dir, "Occupancy");
  for (Index isensor = 0; isensor < device->numSensors(); isensor++) {
    m_hists.emplace_back(*device->getSensor(isensor), sub);
  }
}

TH2D* Analyzers::Occupancy::getHitOcc(Index isensor)
{
  validSensor(isensor);
  return m_hists.at(isensor).hits;
}

TH1D* Analyzers::Occupancy::getHitOccDist(Index isensor)
{
  if (!_postProcessed)
    throw std::runtime_error(
        "Occupancy: requested plot needs to be generated by post-processing");
  validSensor(isensor);
  return m_hists.at(isensor).pixelOccupancy;
}

uint64_t Analyzers::Occupancy::getTotalHitOccupancy(Index isensor)
{
  return static_cast<uint64_t>(getHitOcc(isensor)->GetEntries());
}

void Analyzers::Occupancy::processEvent(const Storage::Event* event)
{
  assert(event && "Analyzer: can't process null events");

  // Throw an error for sensor / plane mismatch
  eventDeviceAgree(event);

  // Check if the event passes the cuts
  if (!checkCuts(event))
    return;

  m_numEvents += 1;

  // 0.- Loop in planes
  for (Index nplane = 0; nplane < event->numPlanes(); nplane++) {
    const Storage::Plane* plane = event->getPlane(nplane);
    auto& hists = m_hists.at(nplane);

    // 1.- Loop in hits within plane and fill histos
    for (Index nhit = 0; nhit < plane->numHits(); nhit++) {
      const Storage::Hit* hit = plane->getHit(nhit);

      // Check if the hit passes the cuts
      if (!checkCuts(hit))
        continue;

      hists.hits->Fill(hit->posPixel().x(), hit->posPixel().y());
    }

    // 2.- Loop in clusters within plane and fill histos
    for (Index ncluster = 0; ncluster < plane->numClusters(); ncluster++) {
      const Storage::Cluster* cluster = plane->getCluster(ncluster);

      // Check if the cluster passes the cuts
      if (!checkCuts(cluster))
        continue;

      hists.clusters->Fill(cluster->posPixel().x(), cluster->posPixel().y());

      for (Index ihit = 0; ihit < cluster->numHits(); ++ihit) {
        const Storage::Hit* hit = cluster->getHit(ihit);
        hists.clusteredHits->Fill(hit->posPixel().x(), hit->posPixel().y());
      }
    }
  }
}

void Analyzers::Occupancy::postProcessing()
{
  for (auto hists = m_hists.begin(); hists != m_hists.end(); ++hists) {
    TH2D* hits = hists->hits;
    TH1D* pixels = hists->pixelOccupancy;

    // rebin histogram to maximum occupancy range
    pixels->SetBins(100, 0, hits->GetMaximum() / m_numEvents);
    pixels->Reset();
    for (int bx = 1; bx <= hits->GetNbinsX(); ++bx) {
      for (int by = 1; by <= hits->GetNbinsY(); ++by) {
        double numHits = hits->GetBinContent(bx, by);
        if (numHits != 0)
          pixels->Fill(numHits / m_numEvents);
      }
    }
  }
}
