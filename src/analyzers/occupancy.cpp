#include "occupancy.h"

#include <cassert>
#include <iostream>
#include <math.h>
#include <sstream>

#include <TDirectory.h>
#include <TH1D.h>
#include <TH2D.h>

#include "mechanics/device.h"
#include "mechanics/sensor.h"
#include "processors/processors.h"
#include "storage/cluster.h"
#include "storage/event.h"
#include "storage/hit.h"
#include "storage/plane.h"
#include "storage/track.h"

Analyzers::Occupancy::Occupancy(const Mechanics::Device* device,
                                TDirectory* dir,
                                const char* suffix)
    : SingleAnalyzer(device, dir, suffix, "Occupancy")
    , m_numEvents(0)
{
  assert(device && "Analyzer: can't initialize with null device");
  bookHistos(makeGetDirectory("Occupancy"));
}

void Analyzers::Occupancy::bookHistos(TDirectory* plotDir)
{
  std::string name, title;
  TH1D* h1;
  TH2D* h2;

  for (unsigned int nsens = 0; nsens < _device->getNumSensors(); nsens++) {
    const Mechanics::Sensor* sensor = _device->getSensor(nsens);

    auto areaPix =
        sensor->sensitiveAreaPixel(); // col_min,col_max,row_min,row_max
    auto areaXY =
        sensor->sensitiveEnvelopeGlobal(); // x_min, x_max, y_min, y_max

    // raw hits in pixel coordinates
    name = sensor->name() + "-HitMap";
    title = sensor->name() + " Hit Map";
    h2 = new TH2D(name.c_str(),
                  title.c_str(),
                  sensor->numCols(),
                  areaPix[0],
                  areaPix[1],
                  sensor->numRows(),
                  areaPix[2],
                  areaPix[3]);
    h2->GetXaxis()->SetTitle("pixel column");
    h2->GetYaxis()->SetTitle("pixel row");
    h2->SetDirectory(plotDir);
    m_occHits.push_back(h2);

    // clustered hits in pixel coordinates
    name = sensor->name() + "-ClusteredHitMap";
    title = sensor->name() + " Clustered Hit Map";
    h2 = new TH2D(name.c_str(),
                  title.c_str(),
                  sensor->numCols(),
                  areaPix[0],
                  areaPix[1],
                  sensor->numRows(),
                  areaPix[2],
                  areaPix[3]);
    h2->GetXaxis()->SetTitle("pixel column");
    h2->GetYaxis()->SetTitle("pixel row");
    h2->SetDirectory(plotDir);
    m_occClustersHits.push_back(h2);

    // cluster positions in global xy coordinates
    name = sensor->name() + "-ClusterMap";
    title = sensor->name() + " Cluster Hit Map";
    TH2D* h2 = new TH2D(name.c_str(),
                        title.c_str(),
                        3 * sensor->numCols(),
                        areaXY[0],
                        areaXY[1],
                        3 * sensor->numRows(),
                        areaXY[2],
                        areaXY[3]);
    h2->GetXaxis()->SetTitle("global x position");
    h2->GetYaxis()->SetTitle("global y position");
    h2->SetDirectory(plotDir);
    m_occClusters.push_back(h2);

    // occupancy distribution
    name = sensor->name() + "-PixelOccupancy";
    title = sensor->name() + " Pixel Occupancy distribution";
    h1 = new TH1D(name.c_str(), title.c_str(), 100, 0, 1);
    h1->GetXaxis()->SetTitle("hits / event");
    h1->SetDirectory(plotDir);
    m_occPixels.push_back(h1);
  }
}

TH2D* Analyzers::Occupancy::getHitOcc(unsigned int nsensor)
{
  validSensor(nsensor);
  return m_occHits.at(nsensor);
}

TH1D* Analyzers::Occupancy::getHitOccDist(unsigned int nsensor)
{
  if (!_postProcessed)
    throw std::runtime_error(
        "Occupancy: requested plot needs to be generated by post-processing");
  validSensor(nsensor);
  return m_occPixels.at(nsensor);
}

uint64_t Analyzers::Occupancy::getTotalHitOccupancy(unsigned int nsensor)
{
  validSensor(nsensor);
  return static_cast<uint64_t>(m_occHits.at(nsensor)->GetEntries());
}

void Analyzers::Occupancy::processEvent(const Storage::Event* event)
{
  assert(event && "Analyzer: can't process null events");

  // Throw an error for sensor / plane mismatch
  eventDeviceAgree(event);

  // Check if the event passes the cuts
  if (!checkCuts(event))
    return;

  m_numEvents += 1;

  // 0.- Loop in planes
  for (unsigned int nplane = 0; nplane < event->numPlanes(); nplane++) {
    const Storage::Plane* plane = event->getPlane(nplane);
    TH2D* hits = m_occHits.at(nplane);
    TH2D* clustersHits = m_occClustersHits.at(nplane);
    TH2D* clusters = m_occClusters.at(nplane);

    // 1.- Loop in hits within plane and fill histos
    for (unsigned int nhit = 0; nhit < plane->numHits(); nhit++) {
      const Storage::Hit* hit = plane->getHit(nhit);

      // Check if the hit passes the cuts
      if (!checkCuts(hit))
        continue;

      hits->Fill(hit->col(), hit->row());
    }

    // 2.- Loop in clusters within plane and fill histos
    for (unsigned int ncluster = 0; ncluster < plane->numClusters();
         ncluster++) {
      const Storage::Cluster* cluster = plane->getCluster(ncluster);

      // Check if the cluster passes the cuts
      if (!checkCuts(cluster))
        continue;

      clusters->Fill(cluster->posGlobal().x(), cluster->posGlobal().y());

      for (Index ihit = 0; ihit < cluster->numHits(); ++ihit) {
        const Storage::Hit* hit = cluster->getHit(ihit);
        clustersHits->Fill(hit->col(), hit->row());
      }
    }
  }
}

void Analyzers::Occupancy::postProcessing()
{
  for (unsigned int nsens = 0; nsens < _device->getNumSensors(); nsens++) {
    const Mechanics::Sensor* sensor = _device->getSensor(nsens);
    TH2D* hits = m_occHits.at(nsens);
    TH1D* pixels = m_occPixels.at(nsens);

    // rebin histogram to maximum occupancy range
    pixels->SetBins(100, 0, hits->GetMaximum() / m_numEvents);
    pixels->Reset();
    for (int bx = 1; bx <= hits->GetNbinsX(); ++bx) {
      for (int by = 1; by <= hits->GetNbinsY(); ++by) {
        double numHits = hits->GetBinContent(bx, by);
        if (numHits != 0)
          pixels->Fill(numHits / m_numEvents);
      }
    }
  }
}
