#include "occupancy.h"

#include <cassert>
#include <iostream>
#include <math.h>
#include <sstream>

#include <TDirectory.h>
#include <TH1D.h>
#include <TH2D.h>

#include "mechanics/device.h"
#include "mechanics/sensor.h"
#include "processors/processors.h"
#include "storage/cluster.h"
#include "storage/event.h"
#include "storage/hit.h"
#include "storage/plane.h"
#include "storage/track.h"

Analyzers::Occupancy::Occupancy(const Mechanics::Device* device,
                                TDirectory* dir,
                                const char* suffix)
    : SingleAnalyzer(device, dir, suffix, "Occupancy")
    , m_numEvents(0)
{
  assert(device && "Analyzer: can't initialize with null device");
  bookHistos(*device, makeGetDirectory("Occupancy"));
}

void Analyzers::Occupancy::bookHistos(const Mechanics::Device& device,
                                      TDirectory* dir)
{
  std::string name, title;
  TH1D* h1;
  TH2D* h2;

  for (Index isensor = 0; isensor < device.numSensors(); isensor++) {
    const Mechanics::Sensor* sensor = device.getSensor(isensor);
    auto area = sensor->sensitiveAreaPixel();

    // raw hits in pixel coordinates
    name = sensor->name() + "-HitMap";
    title = sensor->name() + " Hit Map";
    h2 = new TH2D(name.c_str(),
                  title.c_str(),
                  sensor->numCols(),
                  area.axes[0].min,
                  area.axes[0].max,
                  sensor->numRows(),
                  area.axes[1].min,
                  area.axes[1].max);
    h2->GetXaxis()->SetTitle("pixel column");
    h2->GetYaxis()->SetTitle("pixel row");
    h2->SetDirectory(dir);
    m_occHits.push_back(h2);

    // clustered hits in pixel coordinates
    name = sensor->name() + "-ClusteredHitMap";
    title = sensor->name() + " Clustered Hit Map";
    h2 = new TH2D(name.c_str(),
                  title.c_str(),
                  sensor->numCols(),
                  area.axes[0].min,
                  area.axes[0].max,
                  sensor->numRows(),
                  area.axes[1].min,
                  area.axes[1].max);
    h2->GetXaxis()->SetTitle("pixel column");
    h2->GetYaxis()->SetTitle("pixel row");
    h2->SetDirectory(dir);
    m_occClustersHits.push_back(h2);

    // cluster positions in pixel coordinates
    name = sensor->name() + "-ClusterMap";
    title = sensor->name() + " Cluster Hit Map";
    TH2D* h2 = new TH2D(name.c_str(),
                        title.c_str(),
                        3 * sensor->numCols(),
                        area.axes[0].min,
                        area.axes[0].max,
                        3 * sensor->numRows(),
                        area.axes[1].min,
                        area.axes[1].max);
    h2->GetXaxis()->SetTitle("pixel column");
    h2->GetYaxis()->SetTitle("pixel row");
    h2->SetDirectory(dir);
    m_occClusters.push_back(h2);

    // occupancy distribution
    name = sensor->name() + "-PixelOccupancy";
    title = sensor->name() + " Pixel Occupancy distribution";
    h1 = new TH1D(name.c_str(), title.c_str(), 100, 0, 1);
    h1->GetXaxis()->SetTitle("hits / event");
    h1->SetDirectory(dir);
    m_occPixels.push_back(h1);
  }
}

TH2D* Analyzers::Occupancy::getHitOcc(Index isensor)
{
  validSensor(isensor);
  return m_occHits.at(isensor);
}

TH1D* Analyzers::Occupancy::getHitOccDist(Index isensor)
{
  if (!_postProcessed)
    throw std::runtime_error(
        "Occupancy: requested plot needs to be generated by post-processing");
  validSensor(isensor);
  return m_occPixels.at(isensor);
}

uint64_t Analyzers::Occupancy::getTotalHitOccupancy(Index isensor)
{
  validSensor(isensor);
  return static_cast<uint64_t>(m_occHits.at(isensor)->GetEntries());
}

void Analyzers::Occupancy::processEvent(const Storage::Event* event)
{
  assert(event && "Analyzer: can't process null events");

  // Throw an error for sensor / plane mismatch
  eventDeviceAgree(event);

  // Check if the event passes the cuts
  if (!checkCuts(event))
    return;

  m_numEvents += 1;

  // 0.- Loop in planes
  for (Index nplane = 0; nplane < event->numPlanes(); nplane++) {
    const Storage::Plane* plane = event->getPlane(nplane);
    TH2D* hits = m_occHits.at(nplane);
    TH2D* clustersHits = m_occClustersHits.at(nplane);
    TH2D* clusters = m_occClusters.at(nplane);

    // 1.- Loop in hits within plane and fill histos
    for (Index nhit = 0; nhit < plane->numHits(); nhit++) {
      const Storage::Hit* hit = plane->getHit(nhit);

      // Check if the hit passes the cuts
      if (!checkCuts(hit))
        continue;

      hits->Fill(hit->posPixel().x(), hit->posPixel().y());
    }

    // 2.- Loop in clusters within plane and fill histos
    for (Index ncluster = 0; ncluster < plane->numClusters(); ncluster++) {
      const Storage::Cluster* cluster = plane->getCluster(ncluster);

      // Check if the cluster passes the cuts
      if (!checkCuts(cluster))
        continue;

      clusters->Fill(cluster->posPixel().x(), cluster->posPixel().y());

      for (Index ihit = 0; ihit < cluster->numHits(); ++ihit) {
        const Storage::Hit* hit = cluster->getHit(ihit);
        clustersHits->Fill(hit->posPixel().x(), hit->posPixel().y());
      }
    }
  }
}

void Analyzers::Occupancy::postProcessing()
{
  for (Index isensor = 0; isensor < _device->getNumSensors(); isensor++) {
    TH2D* hits = m_occHits.at(isensor);
    TH1D* pixels = m_occPixels.at(isensor);

    // rebin histogram to maximum occupancy range
    pixels->SetBins(100, 0, hits->GetMaximum() / m_numEvents);
    pixels->Reset();
    for (int bx = 1; bx <= hits->GetNbinsX(); ++bx) {
      for (int by = 1; by <= hits->GetNbinsY(); ++by) {
        double numHits = hits->GetBinContent(bx, by);
        if (numHits != 0)
          pixels->Fill(numHits / m_numEvents);
      }
    }
  }
}
